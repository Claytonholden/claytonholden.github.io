<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Python Projects ¬∑ CYBR-2101 ¬∑ Clayton Holden</title>
  <meta name="description" content="Python console apps and a baseball walkup song player built as part of my CYBR-2101 Python Essentials coursework." />
  <link rel="icon" href="data:,">
  <style>
    :root{
      --bg:#0b0d10; --card:#11151b; --ink:#e8edf3; --muted:#a7b3c2; --accent:#6ae3ff; --line:#1f2630;
      --radius:18px; --shadow:0 10px 30px rgba(0,0,0,.35);
    }
    @media (prefers-color-scheme: light){
      :root{ --bg:#f6f8fb; --card:#ffffff; --ink:#0b1220; --muted:#475569; --accent:#0066ff; --line:#e5e9f0; }
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font:15px/1.6 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
      background:radial-gradient(1200px 800px at 80% -10%,rgba(106,227,255,.12),transparent),
                 linear-gradient(180deg,rgba(255,255,255,.02),transparent 200px), var(--bg);
      color:var(--ink);
    }
    .wrap{max-width:1100px;margin:0 auto;padding:28px 20px 60px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:24px}
    .brand{display:flex;align-items:center;gap:12px;text-decoration:none;color:var(--ink)}
    .logo{
      width:42px;height:42px;border-radius:14px;background:
        radial-gradient(14px 10px at 30% 30%, rgba(255,255,255,.3), transparent),
        linear-gradient(135deg, var(--accent), #8ef7c2);
      box-shadow:var(--shadow);
    }
    nav a{color:var(--muted);text-decoration:none;margin-left:14px;font-weight:600}
    .hero{
      border:1px solid var(--line);
      background:linear-gradient(180deg,rgba(255,255,255,.03),transparent), var(--card);
      border-radius:var(--radius);
      padding:24px;
      box-shadow:var(--shadow);
      margin-bottom:22px;
    }
    .hero h1{margin:0 0 8px;font-size:clamp(24px,4vw,34px);line-height:1.15}
    .hero p{margin:0;color:var(--muted)}
    .chips{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px}
    .chip{font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid var(--line);color:var(--muted)}

    .section-intro{
      margin:18px 0 10px;
      font-weight:600;
      color:var(--muted);
      letter-spacing:.04em;
      text-transform:uppercase;
      font-size:12px;
    }

    .code-section{
      border:1px solid var(--line);
      background:var(--card);
      border-radius:var(--radius);
      padding:18px 18px 16px;
      margin-bottom:20px;
      box-shadow:0 10px 25px rgba(0,0,0,.30);
      overflow:hidden;
    }
    .code-section h2{
      margin:0 0 4px;
      font-size:18px;
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:8px;
    }
    .code-section .meta{
      margin:0 0 12px;
      font-size:13px;
      color:var(--muted);
    }
    .filename{
      font-size:12px;
      color:var(--muted);
      font-weight:400;
    }

    pre{
      margin:0;
      overflow:auto;
      padding:12px;
      border-radius:12px;
      background:#05070b;
      border:1px solid #242b35;
    }
    code{
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:13px;
      color:#e8edf3;
      white-space:pre;
    }

    .screenshot-row{
      display:flex;
      flex-wrap:wrap;
      gap:16px;
      margin-top:10px;
    }
    figure{
      margin:0;
      flex:1 1 260px;
    }
    figure img{
      max-width:100%;
      border-radius:12px;
      border:1px solid var(--line);
      display:block;
    }
    figure figcaption{
      margin-top:6px;
      font-size:12px;
      color:var(--muted);
    }

    footer{margin-top:32px;color:var(--muted);font-size:13px}
    a{color:var(--accent)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <a class="brand" href="/">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <strong>Clayton Holden</strong><br>
          <span style="color:var(--muted);font-size:13px">CYBR-2101 ¬∑ Python Projects</span>
        </div>
      </a>
      <nav>
        <a href="/">Home</a>
        <a href="/PythonEssentials/index.md">Python Essentials</a>
        <a href="/files/ClaytonHoldenResume.pdf" target="_blank" rel="noopener">Resume</a>
      </nav>
    </header>

    <section class="hero">
      <h1>Python Essentials ‚Äì CYBR-2101 Project Portfolio</h1>
      <p>
        This page is my CYBR-2101 Assignment 2 portfolio update. It showcases the small practice apps I built
        while learning Python, plus my final Baseball Walkup Song Player project, with code samples,
        screenshots, and a link to the GitHub repository.
      </p>
      <div class="chips">
        <span class="chip">CYBR-2101</span>
        <span class="chip">GitHub Pages</span>
        <span class="chip">Final Project</span>
        <span class="chip">Console Apps</span>
      </div>
    </section>

    <!-- Assignment summary + skills + repo link -->
    <p class="section-intro">Assignment 2 ‚Äì Portfolio overview & skills</p>
    <section class="code-section">
      <h2>Project Overview</h2>
      <p class="meta">
        Over eight weeks of CYBR-2101 I built a series of small console apps (calculator, decision helper,
        loops & lists practice, and a function lab) and then pulled the skills together into a full project:
        a Baseball Walkup Song Player that manages players, songs, and playback using external libraries.
      </p>

      <h3 style="margin:10px 0 4px;font-size:15px;">Skills learned</h3>
      <ul style="margin:0 0 10px 18px;color:var(--muted);font-size:14px;">
        <li>Working with user input, validation, and clear error messages.</li>
        <li>Using control flow (if/elif, loops) and lists/dictionaries to organize data.</li>
        <li>Writing reusable functions and keeping main program logic clean.</li>
        <li>Doing basic file I/O and working with JSON to save persistent data.</li>
        <li>Integrating external libraries (<code>yt-dlp</code>, <code>vlc</code>) to control real-world tools.</li>
      </ul>

      <h3 style="margin:10px 0 4px;font-size:15px;">AI concepts & workflow</h3>
      <p class="meta" style="margin-bottom:8px;">
        I treated AI as a coding partner, not a replacement. I used tools like ChatGPT to help brainstorm structure,
        think through edge cases, and clean up documentation, while I wrote, tested, and debugged the actual code myself.
        This mirrors how AI is used professionally: to speed up iteration while I stay responsible for design, logic,
        and quality.
      </p>

      <h3 style="margin:10px 0 4px;font-size:15px;">GitHub repository</h3>
      <p class="meta">
        The source code for these projects lives in my portfolio repository:
        <br>
        <a href="https://github.com/Claytonholden/claytonholden.github.io/tree/main/projects" target="_blank" rel="noopener">
          GitHub ¬∑ claytonholden.github.io ¬∑ <code>/projects/</code>
        </a>
        <br>
        Final project folder:
        <a href="https://github.com/Claytonholden/claytonholden.github.io/tree/main/projects/WalkupSongPlayer" target="_blank" rel="noopener">
          /projects/WalkupSongPlayer
        </a>
      </p>
    </section>

    <!-- Screenshots section (expects images you upload to /projects/...) -->
    <p class="section-intro">Screenshots</p>
    <section class="code-section">
      <h2>Python project screenshots</h2>
      <p class="meta">
        These screenshots show the programs actually running in the terminal and the Walkup Song Player menu in use.
      </p>
      <div class="screenshot-row">
        <figure>
          <img src="/projects/screenshots/python-calculator.png" alt="CLI calculator running in terminal" />
          <figcaption>CLI Calculator performing a calculation with input validation.</figcaption>
        </figure>
        <figure>
          <img src="/projects/screenshots/python-loops-list.png" alt="Loops and list app menu" />
          <figcaption>Loops & Lists app with menu-driven interface and dynamic list updates.</figcaption>
        </figure>
        <figure>
          <img src="/projects/WalkupSongPlayer/walkup-main-menu.png" alt="Baseball Walkup Song Player main menu" />
          <figcaption>Baseball Walkup Song Player showing players, commands, and now-playing status.</figcaption>
        </figure>
      </div>
      <p class="meta" style="margin-top:10px;">
        (On GitHub: these images are stored under <code>/projects/screenshots/</code> and
        <code>/projects/WalkupSongPlayer/</code> so they render correctly on the live Pages site.)
      </p>
    </section>

    <p class="section-intro">Core practice apps</p>

    <!-- Calculator -->
    <section class="code-section" id="calculator">
      <h2>CLI Calculator <span class="filename">(Calc.py)</span></h2>
      <p class="meta">
        A basic four-function calculator that practices user input, numeric conversion, and error handling.
      </p>
      <pre><code>print("Simple Python Calculator")
print("Type 'q' at any time to quit.\n")

while True:
    # first number
    num1_input = input("Enter the first number: ")
    if num1_input.lower() == 'q':
        print("Goodbye!")
        break

    try:
        num1 = float(num1_input)
    except ValueError:
        print("Error: Please enter a valid number.\n")
        continue

    # operator
    op = input("Enter operator (+, -, *, /): ").strip()
    if op.lower() == 'q':
        print("Goodbye!")
        break
    elif op not in ['+', '-', '*', '/']:
        print("Error: Invalid operator. Please use +, -, *, or /.\n")
        continue

    # second number
    num2_input = input("Enter the second number: ")
    if num2_input.lower() == 'q':
        print("Goodbye!")
        break

    try:
        num2 = float(num2_input)
    except ValueError:
        print("Error: Please enter a valid number.\n")
        continue

    # calculation and validation
    if op == '+':
        result = num1 + num2
    elif op == '-':
        result = num1 - num2
    elif op == '*':
        result = num1 * num2
    elif op == '/':
        if num2 == 0:
            print("Error: Cannot divide by zero.\n")
            continue
        else:
            result = num1 / num2

    # result
    print(f"Result: {result}\n")
</code></pre>
    </section>

    <!-- Decision app -->
    <section class="code-section" id="decision-app">
      <h2>Trip Readiness Decision App <span class="filename">(decision_app.py)</span></h2>
      <p class="meta">
        Uses if/elif branching and boolean checks to decide if a user is ‚Äútrip ready‚Äù based on maintenance checks.
        Built to practice conditional logic and clean feedback messages.
      </p>
      <pre><code># Trip Readiness Checker

print("Welcome to the Trip Readiness Checker!\n")

while True:
    gas = input("Is your gas tank at least half full? (yes/no): ").lower()
    oil = input("Have you checked your oil? (yes/no): ").lower()
    tires = input("Are your tires properly inflated? (yes/no): ").lower()
    lights = input("Are all your lights working? (yes/no): ").lower()

    # Check all responses
    if gas == "yes" and oil == "yes" and tires == "yes" and lights == "yes":
        print("You're ready to hit the road! üöó")
    else:
        if gas == "no":
            print("Better stop for gas before you go.")
        if oil == "no":
            print("Check your oil level first.")
        if tires == "no":
            print("Inflate your tires before driving.")
        if lights == "no":
            print("Fix your lights to ensure safety.")
        if gas != "no" and oil != "no" and tires != "no" and lights != "no":
            print("Do a quick maintenance check before you leave.")

    # Ask if the user wants to check another trip
    again = input("\nCheck another trip? (yes/no): ").lower()
    if again != "yes":
        print("Drive safe!")
        break
</code></pre>
    </section>

    <!-- Loops & list app -->
    <section class="code-section" id="loops-lists">
      <h2>Loops & List Practice App <span class="filename">(loops_list_app.py)</span></h2>
      <p class="meta">
        Menu-driven program focused on loops and lists ‚Äì adding, removing, and displaying items
        and reporting summary counts.
      </p>
      <pre><code>print("Loops & Lists App")

# start with an empty list
items = []
# menu loop
while True:  
    print("\nMenu:")
    print("1) Add an item")
    print("2) Remove an item")
    print("3) Show all items")
    print("4) Count items")
    print("5) Exit")

    choice = input("Choose 1-5: ")

    if choice == "1":
        new = input("Enter something to add: ")
        items.append(new)
        print(f"Added '{new}'.")
    elif choice == "2":
        if not items:
            print("The list is empty.")
        else:
            print("Current list:", items)
            remove = input("Enter the item to remove exactly: ")
            if remove in items:
                items.remove(remove)
                print(f"Removed '{remove}'.")
            else:
                print("That item is not in the list.")
    elif choice == "3":
        if not items:
            print("List is empty.")
        else:
            print("Items in your list:")
            for thing in items:       # basic for loop
                print("-", thing)
    elif choice == "4":
        print("You have", len(items), "item(s) in the list.")
    elif choice == "5":
        print("Goodbye!")
        break                        # exit
    else:
        print("Please enter a number from 1‚Äì5.")
</code></pre>
    </section>

    <!-- Function lab -->
    <section class="code-section" id="function-lab">
      <h2>Function Lab <span class="filename">(function_lab.py)</span></h2>
      <p class="meta">
        A lab focused on writing reusable functions ‚Äì taking parameters, returning values,
        and keeping the main program logic clean by delegating work to clearly named functions.
      </p>
      <pre><code>import math

# ---------- Reusable functions ----------

def add(a: float, b: float) -> float:
    """
    Return the sum of two numbers.
    Inputs: a (float), b (float)
    Output: float
    """
    return a + b


def hypotenuse(leg_a: float, leg_b: float) -> float:
    """
    Return the hypotenuse length using the Pythagorean theorem.
    Inputs: leg_a (float), leg_b (float)
    Output: float
    """
    return math.hypot(leg_a, leg_b)


def tip_amount(subtotal: float, tip_percent: float) -> float:
    """
    Return the tip value given a subtotal and tip percent.
    Inputs: subtotal (float), tip_percent (float, e.g., 20 for 20%)
    Output: float tip value
    """
    return subtotal * (tip_percent / 100.0)


def sale_price(price: float, percent_off: float) -> float:
    """
    Return the price after a percentage discount.
    Inputs: price (float), percent_off (float, e.g., 20 for 20% off)
    Output: float final price
    """
    discount = price * (percent_off / 100.0)
    return price - discount


# ---------- Input helpers (validation) ----------

def get_float(prompt: str) -> float:
    """Prompt until the user enters a valid float number."""
    while True:
        raw = input(prompt).strip()
        try:
            return float(raw)
        except ValueError:
            print("Please enter a valid number.")


def get_menu_choice() -> str:
    """Prompt until user selects a valid menu option."""
    while True:
        choice = input("Choose an option (1-5): ").strip()
        if choice in {"1", "2", "3", "4", "5"}:
            return choice
        print("Please enter 1, 2, 3, 4, or 5.")


# ---------- Main program ----------

def main() -> None:
    print("=== Function Lab Demo ===")
    print("This program demonstrates reusable functions with input validation.\n")

    while True:
        print("\nMenu:")
        print("  1) Add two numbers")
        print("  2) Pythagorean theorem (right triangle hypotenuse)")
        print("  3) Tip calculator")
        print("  4) Sale price calculator")
        print("  5) Quit")

        choice = get_menu_choice()

        if choice == "1":
            print("\n[ADD] add(a, b)")
            a = get_float("Enter a: ")
            b = get_float("Enter b: ")
            result = add(a, b)
            print(f"Result: {a} + {b} = {result}")

        elif choice == "2":
            print("\n[PYTHAGOREAN THEOREM] hypotenuse(leg_a, leg_b)")
            a = get_float("Enter leg a: ")
            b = get_float("Enter leg b: ")
            c = hypotenuse(a, b)
            print(f"Hypotenuse = {c:.4f}")

        elif choice == "3":
            print("\n[TIP CALCULATOR] tip_amount(subtotal, tip_percent)")
            subtotal = get_float("Enter meal subtotal: $")
            tip_pct = get_float("Enter tip percent (e.g., 20 for 20%): ")
            tip = tip_amount(subtotal, tip_pct)
            total = subtotal + tip
            print(f"Tip: ${tip:.2f}  |  Total: ${total:.2f}")

        elif choice == "4":
            print("\n[SALE PRICE] sale_price(price, percent_off)")
            price = get_float("Enter original price: $")
            off = get_float("Enter percent off (e.g., 20 for 20%): ")
            final = sale_price(price, off)
            print(f"Final price after {off:.2f}% off: ${final:.2f}")

        elif choice == "5":
            print("Goodbye!")
            break


if __name__ == "__main__":
    main()
</code></pre>
    </section>

    <p class="section-intro">Service learning project</p>

    <!-- Walkup Song Player -->
    <section class="code-section" id="walkup-player">
      <h2>Baseball Walkup Song Player <span class="filename">(finalv2.py)</span></h2>
      <p class="meta">
        Final project: a console-based Walkup Song Manager that lets you store players, associate walkup tracks,
        and play them through a simple menu. This project pulls together everything from input validation and loops
        to file handling, JSON persistence, CSV import, and external libraries for downloading and playing audio.
      </p>
      <pre><code># final_project.py ‚Äî Walk-up Song Manager (Service-Learning Project)
# Features:
# - Plays local audio files with VLC from ./songs
# - Downloads new songs from YouTube via yt-dlp
# - Stores players with jersey number, name, song file, and start time in players.json
# - Remembers volume and start times across runs via config.json / players.json
# - Clean terminal UI: splash screen, clears each loop, shows "Now Playing"
# - NEW: Batch import from data/batters.csv (First,Last,Song,Artist,StartSeconds,Jersey)

import os, sys, time, json, re, csv

BANNER = r"""
    [banner art trimmed for brevity in this view]
"""

BASE = os.path.dirname(os.path.abspath(__file__))
# Make the script's folder the working directory so relative paths always work
os.chdir(BASE)

SONG_DIR = os.path.join(BASE, "songs")
PLAYERS_FILE = os.path.join(BASE, "players.json")
CONFIG_FILE = os.path.join(BASE, "config.json")
DATA_DIR = os.path.join(BASE, "data")
BATTERS_CSV = os.path.join(DATA_DIR, "batters.csv")

os.makedirs(SONG_DIR, exist_ok=True)
os.makedirs(DATA_DIR, exist_ok=True)

AUDIO_EXTS = {".mp3", ".m4a", ".wav", ".flac", ".ogg"}


def clear_screen():
    os.system("cls" if os.name == "nt" else "clear")


# --- Imports with extra safety/guidance ---

YoutubeDL = None
try:
    from yt_dlp import YoutubeDL as _YDL
    YoutubeDL = _YDL
except BaseException:
    YoutubeDL = None

vlc = None
try:
    import vlc as _vlc
    vlc = _vlc
except BaseException:
    vlc = None


# --- Helpers: filesystem / names ---

def sanitize_player_name(name: str) -> str:
    """Convert 'First Last' -> 'first_last' safe filename (letters, numbers, underscores)."""
    name = name.strip().lower()
    name = re.sub(r"\s+", "_", name)          # spaces -> underscore
    name = re.sub(r"[^a-z0-9_]", "", name)    # drop weird chars
    name = re.sub(r"_+", "_", name).strip("_")
    return name or "player"


def unique_path(path: str) -> str:
    """If path exists, append _1, _2, ... until it's unique."""
    if not os.path.exists(path):
        return path
    root, ext = os.path.splitext(path)
    i = 1
    while True:
        candidate = f"{root}_{i}{ext}"
        if not os.path.exists(candidate):
            return candidate
        i += 1


def list_audio_files():
    files = [
        f for f in os.listdir(SONG_DIR)
        if os.path.splitext(f)[1].lower() in AUDIO_EXTS
    ]
    files.sort(key=str.lower)
    return files


# --- JSON persistence ---

def load_json(path: str, default):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        return default
    except Exception:
        # corrupt or unreadable, fall back
        return default


def save_json(path: str, data):
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
    except Exception as e:
        print(f"[x] Failed to save {os.path.basename(path)}: {e}")


def load_players():
    """Return dict jersey -> player dict."""
    data = load_json(PLAYERS_FILE, {})
    players: dict[int, dict] = {}
    if isinstance(data, dict):
        # assume already jersey->record
        for k, v in data.items():
            try:
                jersey = int(k)
                if isinstance(v, dict):
                    players[jersey] = v
            except ValueError:
                continue
    elif isinstance(data, list):
        # older format maybe list of dicts
        for rec in data:
            if isinstance(rec, dict) and "jersey" in rec:
                try:
                    j = int(rec["jersey"])
                    players[j] = rec
                except (ValueError, TypeError):
                    continue
    return players


def save_players(players: dict[int, dict]):
    # store as jersey-string -> record mapping
    data = {str(j): rec for j, rec in players.items()}
    save_json(PLAYERS_FILE, data)


def load_config():
    cfg = load_json(CONFIG_FILE, {})
    if not isinstance(cfg, dict):
        cfg = {}
    if "volume" not in cfg:
        cfg["volume"] = 80
    return cfg


def save_config(cfg: dict):
    save_json(CONFIG_FILE, cfg)


# --- yt-dlp download ---

def newest_mp3(dirpath: str) -> str | None:
    mp3s = [
        os.path.join(dirpath, f)
        for f in os.listdir(dirpath)
        if f.lower().endswith(".mp3")
    ]
    if not mp3s:
        return None
    return max(mp3s, key=lambda p: os.path.getmtime(p))


def download_song(query: str) -> str | None:
    """
    Search YouTube (first result) and download audio as MP3 into SONG_DIR.
    Returns final mp3 path or None.
    """
    if YoutubeDL is None:
        print("[x] yt-dlp not installed. Run: pip install yt-dlp")
        return None

    before = set(os.listdir(SONG_DIR))

    bar = "[..........]"
    print("\n[Download] Searching + downloading:", query)
    print(bar, "Downloading...", end="", flush=True)

    ydl_opts = {
        "format": "bestaudio/best",
        "noplaylist": True,
        "default_search": "ytsearch1",
        "outtmpl": os.path.join(SONG_DIR, "%(title)s.%(ext)s"),
        "postprocessors": [{
            "key": "FFmpegExtractAudio",
            "preferredcodec": "mp3",
            "preferredquality": "192",
        }],
        "quiet": True,
        "no_warnings": True,
    }

    try:
        with YoutubeDL(ydl_opts) as ydl:
            ydl.download([query])
    except Exception as e:
        print("\n[x] yt-dlp error:", e)
        return None

    after = set(os.listdir(SONG_DIR))
    new_files = [f for f in after - before if f.lower().endswith(".mp3")]
    if new_files:
        full = [os.path.join(SONG_DIR, f) for f in new_files]
        newest = max(full, key=lambda p: os.path.getmtime(p))
        print("\r[##########] Download complete!")
        print(f"[‚úì] Saved: {os.path.basename(newest)}")
        return newest

    newest = newest_mp3(SONG_DIR)
    if newest:
        print("\r[##########] Download finished (picked newest mp3).")
        print(f"[‚úì] Saved: {os.path.basename(newest)}")
        return newest

    print("\n[x] Download finished but mp3 not found. Check songs folder.")
    return None


# --- Player registry helpers ---

def prompt_int(prompt: str, allow_blank: bool = False) -> int | None:
    while True:
        text = input(prompt).strip()
        if allow_blank and text == "":
            return None
        if text.isdigit():
            return int(text)
        print("Please enter a whole number.")


def add_player_from_file(path: str, players: dict[int, dict]) -> dict[int, dict]:
    """
    Interactive version: ask for jersey, name, start time, and rename file to first_last.mp3.
    """
    if not path or not os.path.exists(path):
        print("[x] File not found for player setup.")
        return players

    print("\nSet up player for this song.")
    name = input("Player name (First Last): ").strip()
    if not name:
        print("[!] Skipping player setup.")
        return players

    jersey = prompt_int("Jersey number: ")
    start = prompt_int("Start time in seconds (0 for start of song): ")
    if start is None:
        start = 0

    safe = sanitize_player_name(name)
    target = os.path.join(SONG_DIR, safe + ".mp3")
    target = unique_path(target)

    try:
        os.rename(path, target)
        filename = os.path.basename(target)
        print(f"[‚úì] Renamed to {filename}")
    except Exception as e:
        print("[x] Rename failed, keeping original filename:", e)
        filename = os.path.basename(path)

    players[jersey] = {
        "jersey": jersey,
        "name": name,
        "file": filename,
        "start": int(start),
    }
    save_players(players)
    print(f"[‚úì] Player {name} (# {jersey}) saved.")
    return players


def add_player_auto_from_file(
    path: str,
    name: str,
    jersey: int,
    start: int,
    players: dict[int, dict],
) -> dict[int, dict]:
    """
    Non-interactive version used by CSV importer.
    Uses given name/jersey/start and renames file to first_last.mp3.
    """
    if not path or not os.path.exists(path):
        print("[x] File not found for player setup.")
        return players

    safe = sanitize_player_name(name)
    target = os.path.join(SONG_DIR, safe + ".mp3")
    target = unique_path(target)

    try:
        os.rename(path, target)
        filename = os.path.basename(target)
        print(f"[‚úì] Renamed to {filename}")
    except Exception as e:
        print("[x] Rename failed, keeping original filename:", e)
        filename = os.path.basename(path)

    players[jersey] = {
        "jersey": jersey,
        "name": name,
        "file": filename,
        "start": int(start) if start is not None else 0,
    }
    save_players(players)
    print(f"[‚úì] Player {name} (# {jersey}) saved.")
    return players


def print_players(players: dict[int, dict]):
    if not players:
        print("(No players configured yet. Use 'd' or 'c' to add players.)")
        return
    print("Jersey | Player Name           | File                     | Start")
    print("-------+------------------------+--------------------------+------")
    for jersey in sorted(players.keys()):
        p = players[jersey]
        name = p.get("name", "?")
        fname = p.get("file", "?")
        start = p.get("start", 0)
        print(f"{jersey:>6} | {name:<22} | {fname:<24} | {start:>4}s")


def edit_player(players: dict[int, dict]) -> dict[int, dict]:
    """Edit an existing player via submenu: name, jersey, start time, file, delete."""
    if not players:
        print("No players to edit.")
        return players

    print_players(players)
    jersey = prompt_int("\nEnter jersey number to edit (or 0 to cancel): ")
    if jersey in (None, 0):
        return players
    if jersey not in players:
        print("No player with that jersey.")
        return players

    p = players[jersey]
    while True:
        print(f"\nEditing #{jersey} - {p.get('name','?')}")
        print("1) Change player name")
        print("2) Change jersey number")
        print("3) Change start time")
        print("4) Change audio file")
        print("5) Delete player")
        print("0) Back")
        choice = input("Choice: ").strip()
        if choice == "1":
            new_name = input("New name: ").strip()
            if new_name:
                p["name"] = new_name
                print("[‚úì] Name updated.")
        elif choice == "2":
            new_j = prompt_int("New jersey number: ")
            if new_j is not None:
                if new_j in players and new_j != jersey:
                    print("Another player already has that jersey.")
                else:
                    players.pop(jersey)
                    jersey = new_j
                    p["jersey"] = new_j
                    players[jersey] = p
                    print("[‚úì] Jersey updated.")
        elif choice == "3":
            new_s = prompt_int("New start time (seconds): ")
            if new_s is not None:
                p["start"] = int(new_s)
                print("[‚úì] Start time updated.")
        elif choice == "4":
            files = list_audio_files()
            if not files:
                print("No audio files in songs/ to choose from.")
            else:
                print("\nAvailable audio files:")
                for i, name in enumerate(files, 1):
                    print(f"{i}) {name}")
                idx = prompt_int("Select file number: ", allow_blank=True)
                if idx and 1 <= idx <= len(files):
                    p["file"] = files[idx - 1]
                    print("[‚úì] File updated.")
        elif choice == "5":
            confirm = input("Delete this player? (y/n): ").strip().lower()
            if confirm == "y":
                players.pop(jersey, None)
                print("[‚úì] Player deleted.")
                break
        elif choice == "0":
            break
        else:
            print("Unknown option.")

    save_players(players)
    return players


def import_players_from_csv(players: dict[int, dict]) -> dict[int, dict]:
    """
    Batch import from data/batters.csv.

    Expected CSV columns (in order):
      First, Last, Song, Artist, StartSeconds, Jersey(optional)

    - First/Last/Song/Artist are required.
    - StartSeconds defaults to 0 if blank/invalid.
    - Jersey read from column 6 if present; otherwise you‚Äôll be prompted.
    """
    if not os.path.exists(BATTERS_CSV):
        print(f"[x] CSV not found at: {BATTERS_CSV}")
        print("    Make sure data/batters.csv exists.")
        return players

    imported = 0
    try:
        with open(BATTERS_CSV, newline="", encoding="utf-8-sig") as f:
            reader = csv.reader(f)
            for row in reader:
                if not row or all(not cell.strip() for cell in row):
                    continue

                # optional header skip
                first_cell = row[0].strip().lower()
                if first_cell in ("first", "first name", "firstname"):
                    continue

                first = row[0].strip() if len(row) > 0 else ""
                last = row[1].strip() if len(row) > 1 else ""
                song = row[2].strip() if len(row) > 2 else ""
                artist = row[3].strip() if len(row) > 3 else ""
                start_raw = row[4].strip() if len(row) > 4 else ""
                jersey_raw = row[5].strip() if len(row) > 5 else ""

                if not first or not last or not song or not artist:
                    print("[!] Skipping row (missing name or song):", row)
                    continue

                name = f"{first} {last}"
                query = f"{song} {artist}"

                try:
                    start_sec = int(start_raw) if start_raw else 0
                except ValueError:
                    start_sec = 0

                jersey: int | None = None
                if jersey_raw:
                    try:
                        jersey = int(jersey_raw)
                    except ValueError:
                        jersey = None

                if jersey is None:
                    print(f"\nRow for {name} ‚Äî {song} ({artist})")
                    jersey = prompt_int(" Jersey number: ")
                    if jersey is None:
                        print("[!] Skipping row (no jersey).")
                        continue

                if jersey in players:
                    print(f"[!] Jersey {jersey} already exists, skipping {name}.")
                    continue

                print(f"\n[Batch] Downloading for {name} ‚Äî {song} ({artist})")
                path = download_song(query)
                if not path:
                    print("[x] Download failed, skipping this player.")
                    continue

                players = add_player_auto_from_file(
                    path=path,
                    name=name,
                    jersey=jersey,
                    start=start_sec,
                    players=players,
                )
                imported += 1
    except Exception as e:
        print("[x] Error reading CSV:", e)
        return players

    print(f"\n[‚úì] Imported {imported} player(s) from CSV.")
    return players


# --- VLC wrapper ---

class SimplePlayer:
    def __init__(self, volume: int = 80):
        self._mp = None
        self.available = vlc is not None
        self._volume = max(0, min(100, int(volume)))
        if not self.available:
            print("[!] python-vlc or VLC not available; playback disabled.")
            return
        try:
            self._mp = vlc.MediaPlayer()
            self.set_volume(self._volume)
        except Exception as e:
            print("[!] Failed to create VLC player:", e)
            self.available = False

    def play_file(self, path: str, start_sec: int = 0):
        """Play file from given start time (in seconds) without blipping at 0s."""
        if not self.available:
            print("(Playback disabled.)")
            return
        if not os.path.exists(path):
            print("[x] File missing:", path)
            return
        try:
            self._mp.stop()
            self._mp.set_media(vlc.Media(path))

            # If we have a start offset, mute first so you don't hear the beginning
            if start_sec and start_sec > 0:
                self._mp.audio_set_volume(0)
            else:
                self._mp.audio_set_volume(self._volume)

            self._mp.play()

            # Wait briefly until VLC is actually playing before seeking
            for _ in range(50):  # ~1 second max
                state = self._mp.get_state()
                if state in (vlc.State.Playing, vlc.State.Paused):
                    break
                time.sleep(0.02)

            if start_sec and start_sec > 0:
                try:
                    self._mp.set_time(int(start_sec * 1000))
                except Exception:
                    pass
                # Restore real volume after seeking
                self._mp.audio_set_volume(self._volume)

        except Exception as e:
            print("[x] VLC playback error:", e)

    def pause(self):
        if self.available:
            try:
                self._mp.pause()
            except Exception:
                pass

    def stop(self):
        if self.available:
            try:
                self._mp.stop()
            except Exception:
                pass

    def set_volume(self, vol: int):
        self._volume = max(0, min(100, int(vol)))
        if self.available:
            try:
                self._mp.audio_set_volume(self._volume)
            except Exception:
                pass


# --- UI ---

def print_status(now_playing: dict | None, status: str, volume: int):
    print("===========================================")
    print(" Walk-up Song Manager                      ")
    print("-------------------------------------------")
    if now_playing:
        print(f" Now Playing: #{now_playing.get('jersey','?')} "
              f"{now_playing.get('name','?')} "
              f"({now_playing.get('file','?')} @ {now_playing.get('start',0)}s)")
    else:
        print(" Now Playing: (none)")
    print(f" Status: {status:<10} | Volume: {volume}")
    print("===========================================\n")


def main():
    # splash
    clear_screen()
    print(BANNER)
    time.sleep(2.5)

    players = load_players()
    cfg = load_config()
    volume = int(cfg.get("volume", 80))
    sp = SimplePlayer(volume=volume)

    now_playing = None
    status = "Stopped"

    while True:
        clear_screen()
        print_status(now_playing, status, volume)
        print("Current Players:")
        print_players(players)
        print("\nCommands:")
        print("  [jersey]  -> play that player's song")
        print("  d         -> download new song + add player (manual)")
        print("  c         -> import batch from data/batters.csv")
        print("  e         -> edit existing player")
        print("  p         -> pause/resume")
        print("  s         -> stop")
        print("  v NN      -> set volume 0‚Äì100 (e.g., v 80)")
        print("  l         -> list audio files in songs/")
        print("  q         -> quit")

        try:
            cmd = input("\nSelect: ").strip()
        except (EOFError, KeyboardInterrupt):
            print("\nBye.")
            break

        if not cmd:
            continue

        low = cmd.lower()

        if low == "q":
            sp.stop()
            print("Bye.")
            break

        if low == "l":
            print("\nAudio files in songs/:")
            for name in list_audio_files():
                print(" -", name)
            input("\nPress Enter to continue...")
            continue

        if low == "d":
            query = input("Search YouTube (song + artist): ").strip()
            if not query:
                continue
            path = download_song(query)
            if path:
                players = add_player_from_file(path, players)
            input("Press Enter to continue...")
            continue

        if low == "c":
            print(f"\n[Batch Import] Using CSV: {BATTERS_CSV}")
            players = import_players_from_csv(players)
            input("Press Enter to continue...")
            continue

        if low == "e":
            players = edit_player(players)
            input("Press Enter to continue...")
            continue

        if low == "p":
            sp.pause()
            status = "Paused"
            continue

        if low == "s":
            sp.stop()
            status = "Stopped"
            now_playing = None
            continue

        if low.startswith("v"):
            parts = low.split()
            if len(parts) == 2 and parts[1].isdigit():
                volume = int(parts[1])
                volume = max(0, min(100, volume))
                sp.set_volume(volume)
                cfg["volume"] = volume
                save_config(cfg)
                print(f"Volume set to {volume}")
                time.sleep(0.7)
            else:
                print("Usage: v 80")
                time.sleep(1)
            continue

        # jersey selection
        if cmd.isdigit():
            jersey = int(cmd)
            if jersey not in players:
                print("No player with that jersey.")
                time.sleep(1.2)
                continue
            p = players[jersey]
            filename = p.get("file")
            start = int(p.get("start", 0))
            path = os.path.join(SONG_DIR, filename)
            now_playing = p
            status = "Playing"
            sp.play_file(path, start_sec=start)
            continue

        print("Unknown command.")
        time.sleep(1.2)


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        # If something unexpected happens, don't just insta-close.
        print("\n[CRASH] An unexpected error occurred:")
        print(repr(e))
        input("Press Enter to exit...")
</code></pre>
      <p class="meta">
        The full source lives in the GitHub folder linked above. In the live environment it includes the complete
        implementation with VLC playback, YouTube downloads, JSON storage, and CSV batch import.
      </p>
    </section>

    <footer>
      <div>¬© <span id="y"></span> Clayton Holden ‚Ä¢ CYBR-2101 Python project showcase</div>
    </footer>
  </div>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
</body>
</html>
